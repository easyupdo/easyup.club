---
title: c++11
date: 2020-09-14 14:37:43
tags: c11
---
### c11的一些新特性
```c
#include <algorithm>
#include <boost/filesystem.hpp>
#include <cstdio>
#include <functional>
#include <iostream>
#include <map>
#include <memory>
#include <regex>
#include <string>
#include <tuple>
#include <typeinfo>
using namespace std;


//------泛型------
  template<class T>
  void Out(T ta){//普通通用模版
    std::cout<<"<T>L"<<ta<<std::endl;
  }
  template<>//模版的特例化/具体化 <>不能少 本质上还是个模版
  void Out(int ta){
    std::cout<<"<>L"<<ta<<std::endl;
  }
```

<!--more-->
```c
  template
void Out(int ta);//模版的显示实例化 本质是个函数 //用来做声明类型用的,只需要声明就行 不要跟下边的Out(int ta)搞成一个,下边的Out(int ta)不要也可以的

  void Out(int ta){
    std::cout<<"temp"<<ta<<std::endl;
  }

  template<class T1,class ...Args>
  void Out(T1 t1 ,Args... t2){
    std::cout<<"T"<<t1<<std::endl;
      Out(t2 ...);
  }
  //模版的实例化和特例化/具体化
  //函数同名（重载）时，调用优先级通常为：普通函数 >显式具体化(template specilazation)>显式实例化>一般模版函数 
  //实例化:是对模版函数的类型实例化 本质是个函数
  //特例化:是对模版函数的类型指定特定类型   本质还是个模版
  //-------泛型-------




/***
 * 使用function类模版 多态函数包装器 类似函数指针 //闭包(仿函数,std::bind,lammbda)实现的一种.闭包:带有上下文状态的函数
 * */
std::function<void(int, string)> fun_obj;

/***
 * 普通函数
 * */
void fun1(int a, string str) {
  std::cout << "a:" << a << std::endl;
  std::cout << "std:" << str << std::endl;
}

/***
 *  c++11 auto + decltype
 * */
auto fun2(int a) -> decltype(a) { return a; }

/***
 * c++ typeid() 数据类型判断
*/

template <typename T>
void typeid_fun(T t)
{
  if(typeid(t) == typeid(int))
  std::cout<<"int"<<std::endl;
  if(typeid(t) == typeid(string))
  std::cout<<"string"<<std::endl;
  if(typeid(t) == typeid(vector<int>))
  std::cout<<"vector<int>"<<std::endl;
  if(typeid(t) == typeid(vector<vector<int>>))
  std::cout<<"vector<vector<int>>"<<std::endl;
}


/***
 * 宏定义简化函数
 * */
#define pout(x)                  \
  do {                           \
    std::cout << x << std::endl; \
  } while (0);

template <typename T>
void fun4(T t) {
  pout(t);
}

/**
 * 使用模版嵌套类型
 * */

template <typename T1>
void TestCountIf(T1 &v1) {
  int num = std::count_if(v1.begin(), v1.end(), [&](typename T1::value_type a) {
    std::cout << a << std::endl;
    return true;
  });
  std::cout << "CN:" << num << std::endl;
}

/***
 * 使用 std::initializer_list 实现可变参数
 * */
template <typename T>
void p(std::initializer_list<T> l) {
  for (auto x : l) {
    pout(x)
  }
}

/***
 * 模版可变参数
 * */
void p11() {}

template <typename T1, typename... T2>
void p11(T1 t1, T2... args) {
  pout(t1);
  p11(args...);
}
// 模版可变参数

class CT {
 public:
  CT(){pout("CT constr")} CT(int a) : CT() {}
  ~CT() {}
};

/***
 * c++11元组
 * c++11正则表达式
 * 左值 右值 左值引用 右值引用
 * */

void GetFiles() {}

/***
 * c++11 只能指针
 * */
void Ptr() {
  unique_ptr<int> up1(new int(111));
  pout(*up1);

  shared_ptr<int> sp1(new int(222));
  shared_ptr<int> sp2 = sp1;

  pout(*sp1);
  pout(*sp2);
  pout(sp1.use_count());
  sp2.reset();
  pout(sp1.use_count());
}

void Jp(int a) { pout(a); }

/***
 * c++11 右值引用
 * */
void RValue(int&& v) {
  pout(v);
  pout(&v);
}
/*

*/
void Value(int& v) {
  pout(v);
  pout(&v);
}

/**
 * execption div 0 execption
 * */
void Execp() {
  try {
    /* code */
    int b = 0;
    if (!b) {
      throw - 1;
    }
    int div = 10 / b;
  } catch (const std::exception& e) {
    std::cerr << e.what() << '\n';
  }
}

void SetMap() {
  std::map<int, string> m;
  m[1] = "h1";
  m[2] = "h2";
  pout(m.size())
}



int main() {

  std::vector<int>v1 = {1,2,3,4,5};
  TestCountIf(v1);


  vector<int>vi;
  typeid_fun(vi);
  vector<vector<int>>vvi;
  typeid_fun(vvi);


  SetMap();
  //Execp();
  RValue(123 + 123);
  int xv = 123;
  Value(xv);
  RValue(std::move(xv));

  int ia = 1;
  int ib = 2;
  pout(std::plus<int>()(ia, ib));

  std::list<int> sl = {3, 7, 2, 5, 9, 4};
  auto max_it = std::max_element(sl.begin(), sl.end());
  pout(*max_it);

  Ptr();

  // std::invoke(Jp, 999);
  // std::invoke(Ptr);

  std::cout << "hello" << std::endl;
  fun_obj = fun1;
  fun_obj(1, "helo");

  string str = "hello";
  auto s = str;
  std::cout << "s:" << s << std::endl;
  decltype(s) s2 = s;
  std::cout << "type:" << s2 << std::endl;

  auto a1 = fun2(10);
  std::cout << a1 << std::endl;
  pout("helllo");

  p<int>({1, 2, 3, 4, 5});

  p11<int>(11, 22, 33, 44);

  CT* ct = new CT(111);

  /*
  std::string root_dir = "/Users/jay/Work";
  for (auto x : boost::filesystem::directory_iterator(root_dir)) {
    pout(x);
  }
  namespace fs = boost::filesystem;
  fs::path p(root_dir);
  fs::path rs = p.root_directory();
  fs::path rs1 = p.root_name();
  fs::path rs2 = p.root_path();
  pout(p.root_directory());
  pout(p.root_name());
  pout(p.root_path());
  fs::path cs = fs::current_path();

  for (auto x : fs::recursive_directory_iterator("/Users/jay/Data/wenzhou")) {
    // pout(x)
    if (fs::status(x).type() == fs::file_type::directory_file) {
      pout(x)
    }
    if (fs::is_directory(x)) {
      pout(x);
    }
  }
  */

  printf("hello\n");

  Out(1111);

  return 0;
}
```
